package com.yafatek;public class BST {//	private static Node root;	public static void main(String[] args) {		// Create new Tree.		BST bst = new BST();		Node root = null;		//Insert Nodes to BST		root = bst.insertNode(root, 10);		root = bst.insertNode(root, 5);		root = bst.insertNode(root, 15);		root = bst.insertNode(root, 25);		root = bst.insertNode(root, 30);		// Search in BST		// pre Order Traversal		// In Order Traversal		// post order traversal.//		System.out.println(bst.findNodeValue(root,5));//		bst.inOrderTraverseTree(root);//		bst.inorder(root);		// Delete from BST		//todo		// breadth-First search		// depth-first search//		System.out.println(bst.findNodeValue(root, 5));		// Breadth First Search (BFS).		int level = bst.treeHeight(root);		// print each in the Level.		for (int i = 1; i <= level; i++) {			bst.printValueInLevels(root, i);		}		// check if the Tree is a Valid Binary Tree.		boolean isBST = bst.isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);		System.out.println("is binary Tree? " + isBST);	}	/**	 * insert node to BST.	 * hint: if your Method is More than 10 Lines -> then there is something wrong with you Code :)	 *	 * @param focusedNode root node of the tree.	 * @param data        data to insert into  a node.	 * @return new Node after Create it.	 */	public Node insertNode(Node focusedNode, int data) {		// if the root is null, create a new node		if (focusedNode == null) return new Node(data);		// if data less than root value, push the value to the left side.		if (data < focusedNode.data) focusedNode.leftChild = insertNode(focusedNode.leftChild, data);			// data greater or equal root value, push the value to the right side		else focusedNode.rightChild = insertNode(focusedNode.rightChild, data);		return focusedNode;	}	/**	 * Search a Value in a node.	 *	 * @param focusNode node to search in	 * @param data      value to be searched.	 * @return -1 in case of the tree is Empty, otherwise return the value using recursion.	 */	private boolean findNodeValue(Node focusNode, int data) {		// if Tree is Empty return false		if (focusNode == null) return false;		// if the node Contains our Value return true, continue the recursion otherwise.		if (focusNode.data == data) return true;		// recursion on left First then right side to look for the Element.		return data < focusNode.data ? findNodeValue(focusNode.leftChild, data) : findNodeValue(focusNode.rightChild, data);	}	private void inOrderTraverseTree(Node focusNode) {		if (focusNode != null) {			//LDR (Left Data Right)			inOrderTraverseTree(focusNode.leftChild);//L			System.out.println(focusNode.data);//D			inOrderTraverseTree(focusNode.rightChild);//R		}	}	/**	 * Compute the The tree higher level.	 *	 * @param root root node	 * @return integer value represents the higher level(count of paths) edges.	 */	private int treeHeight(Node root) {		// if the Tree is Empty, or Only root Node is exist then the height is 0.		if (root == null) return 0;		else {			// Get the longest path in the left side.			int leftHeight = treeHeight(root.leftChild);			// Get the longest path in the right side.			int rightHeight = treeHeight(root.rightChild);			//if the left side is higher than right side, there is a path exist. increment the height 1 and recursive.			if (leftHeight > rightHeight) return leftHeight + 1;				// if the right side is higher than the left, there is a path exist. increment the right height 1 and recursive.x			else return rightHeight + 1;		}	}	/**	 * print the Data in each level in a tree., Breadth First Search.	 * Complexity in worst case = O(n^2)	 *	 * @param root  tree to Search	 * @param level tree height.	 */	private void printValueInLevels(Node root, int level) {		if (root == null) return;		if (level == 1) System.out.println("root data: " + root.data);		else if (level > 1) {			printValueInLevels(root.leftChild, level - 1);			printValueInLevels(root.rightChild, level - 1);		}	}	/**	 * Method to Check if the tree is a valid Binary Search Tree.	 *	 * @param root tree root	 * @param min  Integer Min Value	 * @param max  Integer Max Value	 * @return true if Tree is BST, false Otherwise.	 */	private boolean isBST(Node root, int min, int max) {		if (root == null) return true;		if (root.data > max || root.data < min) return false;		return isBST(root.leftChild, min, root.data) && isBST(root.rightChild, root.data + 1, max);	}	static class Node {		int data;		Node leftChild;		Node rightChild;		public Node(int data) {			this.data = data;		}		@Override		public String toString() {			return "data = " + data;		}	}}